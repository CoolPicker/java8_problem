Java 8以前, GC组合 ParNew + CMS,
Java 9以后, G1

非G1时 -
JVM的几种GC: Young GC, Old GC, Full GC
ParNew垃圾回收器:
1. 这个垃圾回收器是回收年轻代的,使用的是多线程回收
2. ParNew使用的是复制清除算法,把年轻代分为Eden区和两个Survivor区,JVM参数默认的占比是8:1:1,
系统运行会把对象创建到Eden区,每次YoungGC会标记存活对象,复制到Survivor0中,再次YoungGC时,
再把存活对象复制到Survivor1中.系统运行期间会保证一直有一个Survivor是空着的
3. Eden区的占比有时是可以调优的,如果条件有限,没有大内存的机器,然后对象创建的还特别频繁,
存活的对象比较多,建议把Eden区比例调低一些,让Survivor大一点,宁可YoungGC多一些,
也不要让Survivor触发了动态年龄审核或者放不下存活对象,如果放不下那就把这批对象扔到老年代.
如果是调低Eden,YoungGC会很频繁,但是YoungGC特别快,回收100M垃圾大概也就1ms,
所以,如果内存实在不够,降低Eden的比例也不是不可以.但有条件最好还是加大新生代内存,毕竟YoungGC也是STW.

ParNew非常适合回收年轻代内存.因为年轻代一般存活的对象是很少的,大多数都是刚创建出1ms就变成了垃圾,
所以把极少数存活的对象标记出来,复制成本还是很低的.

CMS - 老年代垃圾回收器
CMS使用的 标记-清除 + 整理 算法,一般在JVM参数会指定 标记清除和整理 的频率,JVM参数默认是 标记-清除 5次之后,才会去整理内存空间.
但这个默认参数不太好,这样做会有大量的内存碎片,如果某一次从年轻代晋升一个大对象,老年代居然找不到一块连续的内存,就会触发Full GC.
生产会把那个值调成0,就是每次CMS垃圾回收后,都会整理内存,虽然每次的回收时间会多一些,但不会出现内存碎片.
CMS垃圾回收的四个步骤
第一步是初始标记: 初始标记的话,只标记GC Root直接引用的对象,只有很少一部分,这个阶段需要STW,但是影响不大,这个过程特别快.
这个过程也可以优化,JVM有个参数是初始标记阶段多线程标记,减少STW时间,正常是单线程标记的.
第二步是并发标记: 这个阶段是不需要STW的,是和系统并行的处理,系统继续运行,然后垃圾回收线程去追踪第一步标记的GC Root,这一步很耗时.
因为在垃圾回收时是允许系统继续创建对象的,所以这个过程会有新的对象进来,也会有标记存活的但是现在变成垃圾,这些有改动的对象JVM都会记下来,
等待下一步处理.这一步有一个缺点,并发清理时也有这个问题,就是会占用CPU资源.如果是一个4核的机器,那会占用一个CPU去垃圾回收,公式是(CPU核数+3)/4.
所以一般CPU资源负载特别高的时候,就俩情况,要不是程序的线程太多了,要不就是频繁FullGC,导致的.
第三步是重新标记: 重新标记阶段,会把并发标记阶段有改动的对象重新标记,这一步需要STW,不过也是比较快的,因为改动的对象不会特别多,
但是要比第一步慢,因为要重新判断这个对象是否GC可达.这里也可以通过JVM参数优化,可以通过参数控制,让CMS在重新标记阶段之前尽量触发一次YoungGC.
这样做的好处是,改动的对象中从存活变为垃圾的那部分,就被清理掉了,缩短STW时间.虽然YoungGC也会造成停顿,但是YoungGC一般频率是比较快的,
此时执行一举两得.
第四步是并发清理: 并发清理是和系统并行的,不需要STW.这个阶段是清理前几个阶段标记好的垃圾.
最后,通过JVM参数设置,每次OldGC后都重新整理内存,整理阶段会把老年代零散的对象排列到一起,减少内存碎片.

FullGC
FullGC就是全面回收整个堆内存,包括新生代/老年代/永久代.出现频繁的FullGC有如下几种情况:
第一种是,内存分配不合理,导致Survivor放不下,或者出发了动态年龄审核机制,频繁的往老年代放对象.
第二种是,有内存泄露问题,导致老年代大部分空间被占用,回收都回收不掉,导致每次新生代晋升一点点对象,就放不下了,触发FullGC.
第三种是,大对象,一般是代码层面的问题,创建了太多的大对象,大对象是直接放入老年代的,大对象过多会导致频繁触发FullGC.
第四种是,永久代满了,触发FullGC,JVM参数设置256M基本够了,如果不出现代码层面的bug,一般不会出现这种情况.
第五种是,有人在代码里误调用了System.gc(),写了这个方法后,如果有机会,JVM就会发生一次FullGC.不过JVM参数可以禁止这种情况,不允许主动调用,需要加上
一般什么情况下要警觉是不是频繁的FullGC了?
1. CPU负载折线上升,特别高
2. 系统卡死了,或者系统处理请求极慢
3. 如果公司有监控系统,会报警

jstat 查看JVM堆栈信息
jstat -gc PID 1000(间隔-ms) 10(打印次数)
返回数据:
S0C - Survivor0的大小
S1C - Survivor1的大小
S0U - Survivor0已使用
S1U - Survivor1已使用
EC - Eden区大小
EU - Eden区已使用 *
OC - 老年代大小
OU - 老年代已使用
MC - 永久代大小
MU - 永久代已使用
CCSC - 压缩类空间大小
CCSU - 压缩类空间已使用
YGC - YoungGC次数 *
YGCT - YoungGC总耗时 *
FGC - FullGC次数
FGCT - FullGC总耗时
GCT - GC总耗时
使用jstat优化,重点观察这几个指标:
1. Eden区对象的增长速度: 上一秒和下一秒EU的数据就可以推断出每秒增长了多少
2. YoungGC频率: 高峰时段YoungGC的频率 是通过Eden的大小 除以 Eden区对象的增长速度
3. YoungGC耗时
4. YoungGC后多少对象存活:
要确定每次存活的对象Survivor到底能不能放得下.要保证每次存活的对象要小于Survivor的50%,否则就会触发动态年龄审核机制
5. 老年代对象增长速度
老年代对象增长速度,决定了Old GC的频率.发生Old GC后,FGC那一列也会增长,FGC那一列其实是FullGC和OldGC的总和.
经过优化后的JVM,每次YoungGC不应该进入太多的对象,不进入或者每次进入几兆是比较好的.
如果晋升的对象特别多,我们需要分析这些对象为什么会进入老年代,上面提到有四种情况会晋升老年代,到底是哪种情况:
如果是Survivor太小,我们很轻易就能看出来,如果每次Young GC后S区都是0,那说明存活的对象太多,S区放不下,都进入了老年代
如果S区不是0,但是每次回收进入老年代都很多,就有可能是触发动态年龄审核,这个最好再通过GC日志看一下,通过JVM参数可以让系统打印每次GC的日志
如果出现内存泄漏,数据一般是这样的,发现每次FGC次数加1后,老年代并没有多少数据被回收掉,占用了很多.这就大概率是内存泄漏,导致老年代回收不掉.
如果是大对象,数据会这样显示,发现即时没有Young GC,OU也会一直在涨,因为大对象是不用经过年轻代的直接进入老年代.
如果内存泄漏和大对象的情况,可以用jmap打印一份内存快照,用MAT工具分析一下到底是什么对象特别大,通过分析出来的堆栈信息就可以定位到代码的位置.
6. FullGC频率多高
Full GC的频率最好控制在一天1次或者几天一次的范围.特别是对时效性要求比较高的系统,一定要减少Full GC次数.
7. 一次FullGC的耗时

什么情况下用ParNew+CMS,它有什么优点
1. 它的优点就是可以优化到极致,极致到没有FullGC只有YoungGC.但是G1不行,对G1的优化只能是尽可能的优化预定的停留时间,
其他的没法参与太多,因为它什么时候YoungGC我们都不确定
2. G1的内存使用率是没有ParNew+CMS高的,G1有这么一个机制,如果G1的某一个Region存活对象达到了85%,
那就不会去回收这个Region,但是那15%呢,如果是垃圾也回收不掉了.
3. G1的掌控性没有ParNew+CMS好,说白了就是心里没底.使用ParNew+CMS可以很确定多久YoungGC/对象增长速度等等.
G1什么时候垃圾回收我们都不知道,如果出现内存泄漏,如果不是几个G的内存泄漏,我们也很难察觉.
总结来说,如果是4C8G的机器,尽量还是用ParNew+CMS垃圾回收器,如果是大内存机器,就是用G1

G1的原理
G1把堆内存平均分成了多个大小相同的Region, 我们首先要设置堆内存的大小,然后G1会根据堆大小除以2048,分成2048个大小相同的Region.
G1也有年轻代/老年代的概念,但没有ParNew+CMS分的那么清楚.G1里的年轻代和老年代都是基于Region的,某些Region属于年轻代,
某些Region属于老年代,由G1动态控制.但是,现在属于年轻代的Region并不永远都是年轻代,如果年轻代的Region被回收了,
下次这个Region可能就存放老年代的数据了.所以,G1的年轻代和老年代都是动态的,但也有个上限.
系统刚开始运行时,会给年轻代分配5%的Region来存放对象,年轻代最多可以占用60%的Region,这60%可以通过JVM参数指定,默认是60%,
如果达到了目标值,就会强制触发YoungGC.
G1的年轻代也是分Eden和Survivor的,因为G1整体使用的都是复制回收算法.只是某些Region属于Eden,某些Region属于Survivor,
系统新创建的对象会被分配到属于Eden的Region,如果垃圾回收就把存活对象复制到Survivor中.
G1的一个特点就是我们可以设置一个预期的停顿时间,即STW时间,比如某个系统时效性要求特别高,每次GC我只允许STW的时间是5ms,
则可以通过JVM参数设置成5ms的停顿,这样G1在垃圾回收时,就会把时间控制在5ms以内.
G1的垃圾回收不一定是年轻代满了,或者老年代满了才去回收.如果是那样,就和ParNew+CMS没区别了,大内存机器也要STW好久.
G1是基于每个Region的性价比去回收的,比如,Region1里有20M对象,回收2ms,Region2里有50M对象回收要4ms.
如果设置的系统停顿时间为5ms,那G1会在要求的时间内尽可能回收更多的对象,它会选择Region2,因为性价比更高.
所以,系统运行中,一直往Eden放对象,如果G1觉得,此时回收一下垃圾,差不多要5ms,那可能G1就会去回收,不会等到年轻代占用60%才去回收.

G1中年轻代的对象什么时候会进入老年代
其实和ParNew+CMS整体上差不多,只有大对象的处理不一样
1. YoungGC存活的对象Survivor放不下
2. YoungGC存活的对象达到Survivor的50%,触发动态年龄审核
3. 对象达到15岁,进入老年代
G1中大对象不会进入老年代,而是专门有一部分Region存放大对象用.如果一个Region放不下大对象,那就会横跨几个Region来存放.

G1的OldGC也不是我们能控制的,G1会根据自己的判断觉得该回收的时候就会回收,不过也是基于复制算法的.
G1的混合回收,如果老年代占比45%,就会触发混合回收,回收整个堆内存,但是混合回收也是会控制在我们设置的停顿时间的范围内的,
如果时间不够,就会分多次回收.混合回收优点和CMS的回收类似:
第一步,初始标记
初始标记需要STW,这一步只标记GC Root直接应用的对象,速度很快
第二步,并发标记
和系统并行,深入的追踪GC Root,标记所有存活的对象,此时系统新创建的对象会被JVM记录,这一步不需要STW
第三步,重新标记
重新标记第二步有改动的对象,要STW.因为只有一小部分改动,速度很快
第四步,混合回收
只有这一步和CMS不一样,CMS这里的回收是和系统并行的.但是G1的混合回收需要STW.混合回收不仅会回收老年代,还会回收新生代和大对象.
如果一次性全回收掉,那时间就太久了,可能达不到我们设置的预期停顿时间,所以G1这里是分几批来回收的,回收一次,系统运行一会,然后再回收一次.
JVM参数可以设置这个值,分几次去回收,默认值是8次,分8次回收.
混合回收还有一个参数我们可以设置,就是空闲的Region达到百分之多少,停止回收,默认是5%.

G1何时会触发FullGC,其实G1的混合回收就相当于ParNew+CMS的FullGC了,因为回收了所有的区域,只不过回收时间可以控制在我们指定的范围内.
但是G1的FullGC就没法控制了,可能要卡顿特别久才能回收完.什么情况下会出现呢?
因为G1的整体是基于复制算法的,如果回收的过程中,发现存活对象找不到可以复制的Region,放不下了.
那就Full GC,开始单线程标记、清理、整理空闲出一批Region,这个过程很慢.

然后说一下G1的优化，G1比较智能，我们可以参与优化的点很少，我们只能合理的设置停顿时间，
不要太小也不要太大，太小GC会太频繁，每秒都在GC。太大的话，停顿时间太久了也不好。

平常工作是怎么进行JVM调优的:
第一步，系统开发完需要自己预估一个JVM参数，也就是你预估每秒大概会有多少的对象进入，然后选几台机器，
把内存比例设置的合理一些就好了，一般公司都会有一套公司级的通用JVM参数模板，
如果是刚开发完，可以直接使用通用模板，反正测试环境还要压测
第二步，测试环境系统压测，使用工具模拟1000人或几千人同时使用，造成每秒几百上千的请求压力，响应时间要控制在200ms。
然后压测期间我们需要通过 jstat 去看下内存使用情况，就是我之前说的那些，什么Eden区增长速度，各个GC的频率啊，
有没有内存泄漏情况等等吧。如果观察YoungGC和Full GC频率没什么问题，系统没有卡顿现象，就可以上线了。
第三步，如果公司有监控系统，就持续监控，如果没有就每天高峰时期，通过jstat查看一下机器的JVM运行状态，如果需要优化，就继续优化
