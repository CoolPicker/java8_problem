目录:
1. JVM在什么情况下会加载一个类?
2. 从实用角度出发,来看看验证/准备和初始化的过程
3. 核心阶段: 初始化
4. 类加载器和双亲委派机制

类加载器和双亲委派机制:
(1), 启动类加载器
加载Java目录下的核心类 即 lib目录
(2), 扩展类加载器
加载Java目录下的扩展程序 即 lib\ext目录
(3), 应用程序类加载器
加载ClassPath环境变量指定的路径中的类,即 开发代码
(4), 自定义类加载器
根据自身需求加载类
(5), 双亲委派机制
JVM的类加载器是有亲子层级结构的,启动类加载器是最上层,扩展类加载器在第二层,第三层是应用程序类加载器,
最后一层是自定义类加载器.
启动类加载器 > 扩展类加载器 > 应用程序类加载器 > 自定义类加载器
基于这个亲子层级结构 > 双亲委派机制
应用程序类加载器类需要加载一个类,会首先委派给自己的父类加载器去加载,最终传导到顶层的类加载器去加载.
如果父类加载器在自己负责加载的范围内,没找到这个类,将下推加载权利给自己的子类加载器.
双亲委派模型: 先找父亲去加载,不行的话再由儿子来加载.
目的: 可以避免多层级的加载器结构重复加载某些类.
源代码加密 > 字节码加密,自定义类加载器来解密

JVM中有哪些内存区域,分别用来干嘛?
1. 存放类的方法区:
JDK1.8以后, Metaspace, 元数据空间, 主要用以 存放开发者写的各种类相关的信息.

2. 执行代码指令用的程序计数器
.java - 源代码
.class - 编译好的字节码 > 对应一系列的字节码指令
当JVM加载类信息到内存之后,实际就会使用自己的 字节码执行引擎,去执行Java代码编译出来的代码指令.
那么在执行字节码指令的时候,JVM里就需要一个特殊的内存区域 > 程序计数器
程序计数器就是用来记录当前执行的字节码指令的位置,即记录目前执行到了哪一条字节码指令.
每个线程都会有自己的一个程序计数器,专门记录当前这个线程目前执行奥了哪一条字节码指令.

3. Java虚拟机栈


4. Java堆内存



